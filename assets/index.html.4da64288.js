import{_ as t,o as r,c as o,a as e,b as a,d as s,e as i,r as l}from"./app.1e68b3ea.js";const d={},c=s('<h1 id="design-principles" tabindex="-1"><a class="header-anchor" href="#design-principles" aria-hidden="true">#</a> Design Principles</h1><h2 id="dry" tabindex="-1"><a class="header-anchor" href="#dry" aria-hidden="true">#</a> DRY</h2><p>DRY - Don&#39;t repeat yourself</p><p>This means not to duplicate code.</p><p>If code is repeated move it to it&#39;s own function and call that function in places where the duplicate code was originally called.</p><h2 id="kiss" tabindex="-1"><a class="header-anchor" href="#kiss" aria-hidden="true">#</a> KISS</h2><p>KISS - Keep it simple stupid</p><p>Don&#39;t over-complicate code when programming.</p><h2 id="yagni" tabindex="-1"><a class="header-anchor" href="#yagni" aria-hidden="true">#</a> YAGNI</h2><p>YAGNI - You ain&#39;t gonna need it</p><p>Functionality should not be added until it&#39;s actually required.</p><p>Code should be designed in a way that additional functionality can be added though.</p><h2 id="slap" tabindex="-1"><a class="header-anchor" href="#slap" aria-hidden="true">#</a> SLAP</h2><p>SLAP - Single level of abstraction principle</p><p>Functions should be short and do one thing.</p><h2 id="low-coupling-high-cohesion" tabindex="-1"><a class="header-anchor" href="#low-coupling-high-cohesion" aria-hidden="true">#</a> Low Coupling / High Cohesion</h2>',16),h={href:"https://medium.com/clarityhub/low-coupling-high-cohesion-3610e35ac4a6",target:"_blank",rel:"noopener noreferrer"},p=i("Medium blog"),u=s('<h2 id="solid" tabindex="-1"><a class="header-anchor" href="#solid" aria-hidden="true">#</a> SOLID</h2><ul><li>S - Single responsibility principle</li><li>O - Open / closed principle</li><li>L - Liskov substitution principle</li><li>I - Interface segregation principle</li><li>D - Dependancy inversion principle</li></ul><h3 id="single-responsibility" tabindex="-1"><a class="header-anchor" href="#single-responsibility" aria-hidden="true">#</a> Single responsibility</h3><blockquote><p>A class should have one, and only one, reason to change.</p></blockquote><ul><li>A class should always a single task, not multiple.</li><li>This keeps the class small, light as easy to work with.</li><li>Classes are more likely to be reused.</li></ul><h3 id="open-closed-principle" tabindex="-1"><a class="header-anchor" href="#open-closed-principle" aria-hidden="true">#</a> Open / closed principle</h3><blockquote><p>You should be able to extend a classes behavior, without modifying it.</p></blockquote><ul><li>Classes should be coded in a way that prevents the need to modify it in future.</li><li>Extend classes or create inherited classes in order to provide new functionality.</li><li>Use the Strategy class design pattern when required.</li></ul><h3 id="liskov-substitution-principle" tabindex="-1"><a class="header-anchor" href="#liskov-substitution-principle" aria-hidden="true">#</a> Liskov substitution principle</h3><blockquote><p>Derived classes must be substitutable for their base classes.</p></blockquote><ul><li>Sub-classes should have the same methods as it&#39;s parent so it can be used the same way.</li></ul><h3 id="interface-segregation-principle" tabindex="-1"><a class="header-anchor" href="#interface-segregation-principle" aria-hidden="true">#</a> Interface segregation principle</h3><blockquote><p>Make fine grained interfaces that are client specific.</p></blockquote><ul><li>Classes inheriting interfaces may not need all inherited methods.</li><li>Interfaces should be small, not complex.</li><li>Makes them easier to reuse.</li></ul><h3 id="dependancy-inversion-principle" tabindex="-1"><a class="header-anchor" href="#dependancy-inversion-principle" aria-hidden="true">#</a> Dependancy inversion principle</h3><blockquote><p>Depend on abstractions, not on concretions.</p></blockquote><ul><li>Use abstract or interfaces instead of concreate classes.</li><li>Concreate classes may require replacing, using abstractions prevents breaking OCP.</li></ul><h2 id="references" tabindex="-1"><a class="header-anchor" href="#references" aria-hidden="true">#</a> References</h2>',18),f={href:"https://thefullstack.xyz/dry-yagni-kiss-tdd-soc-bdfu",target:"_blank",rel:"noopener noreferrer"},b=i("The Full Stack blog"),g={href:"https://devcave.pl/notatnik-juniora/zasady-projektowania-kodu",target:"_blank",rel:"noopener noreferrer"},_=i("Object oriented design principles"),m={href:"https://areknawo.com/10-coding-principles-and-acronyms-demystified/",target:"_blank",rel:"noopener noreferrer"},k=i("10 coding principles"),y=e("h3",{id:"solid-references",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#solid-references","aria-hidden":"true"},"#"),i(" SOLID References")],-1),x={href:"https://medium.com/@mari_azevedo/s-o-l-i-d-principles-what-are-they-and-why-projects-should-use-them-50b85e4aa8b6",target:"_blank",rel:"noopener noreferrer"},v=i("Solid principles blog"),w={href:"https://levelup.gitconnected.com/solid-principles-simplified-php-examples-based-dc6b4f8861f6",target:"_blank",rel:"noopener noreferrer"},S=i("Solid simplified"),I={href:"https://whatis.techtarget.com/definition/SOLID-software-design-principles",target:"_blank",rel:"noopener noreferrer"},q=i("Tech Target"),D={href:"https://www.hashbangcode.com/article/solid-principles-php",target:"_blank",rel:"noopener noreferrer"},L=i("Hash Bang Code");function C(O,A){const n=l("ExternalLinkIcon");return r(),o("div",null,[c,e("ul",null,[e("li",null,[e("a",h,[p,a(n)])])]),u,e("ul",null,[e("li",null,[e("a",f,[b,a(n)])]),e("li",null,[e("a",g,[_,a(n)])]),e("li",null,[e("a",m,[k,a(n)])])]),y,e("ul",null,[e("li",null,[e("a",x,[v,a(n)])]),e("li",null,[e("a",w,[S,a(n)])]),e("li",null,[e("a",I,[q,a(n)])]),e("li",null,[e("a",D,[L,a(n)])])])])}var T=t(d,[["render",C],["__file","index.html.vue"]]);export{T as default};
